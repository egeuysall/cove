// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invites.sql

package supabase

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInvite = `-- name: CreateInvite :one
INSERT INTO invites (code, group_id)
VALUES ($1, $2)
    RETURNING code, group_id, used_by, created_at
`

type CreateInviteParams struct {
	Code    string
	GroupID pgtype.UUID
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) (Invite, error) {
	row := q.db.QueryRow(ctx, createInvite, arg.Code, arg.GroupID)
	var i Invite
	err := row.Scan(
		&i.Code,
		&i.GroupID,
		&i.UsedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getInviteByCode = `-- name: GetInviteByCode :one
SELECT code, group_id, used_by, created_at FROM invites
WHERE code = $1
`

func (q *Queries) GetInviteByCode(ctx context.Context, code string) (Invite, error) {
	row := q.db.QueryRow(ctx, getInviteByCode, code)
	var i Invite
	err := row.Scan(
		&i.Code,
		&i.GroupID,
		&i.UsedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getInvitesByGroup = `-- name: GetInvitesByGroup :many
SELECT code, group_id, used_by, created_at FROM invites
WHERE group_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByGroup(ctx context.Context, groupID pgtype.UUID) ([]Invite, error) {
	rows, err := q.db.Query(ctx, getInvitesByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invite
	for rows.Next() {
		var i Invite
		if err := rows.Scan(
			&i.Code,
			&i.GroupID,
			&i.UsedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedInvite = `-- name: GetUnusedInvite :one
SELECT code, group_id, used_by, created_at FROM invites
WHERE code = $1 AND used_by IS NULL
`

func (q *Queries) GetUnusedInvite(ctx context.Context, code string) (Invite, error) {
	row := q.db.QueryRow(ctx, getUnusedInvite, code)
	var i Invite
	err := row.Scan(
		&i.Code,
		&i.GroupID,
		&i.UsedBy,
		&i.CreatedAt,
	)
	return i, err
}

const markInviteAsUsed = `-- name: MarkInviteAsUsed :exec
UPDATE invites
SET used_by = $1
WHERE code = $2
`

type MarkInviteAsUsedParams struct {
	UsedBy pgtype.UUID
	Code   string
}

func (q *Queries) MarkInviteAsUsed(ctx context.Context, arg MarkInviteAsUsedParams) error {
	_, err := q.db.Exec(ctx, markInviteAsUsed, arg.UsedBy, arg.Code)
	return err
}
